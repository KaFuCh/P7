\chapter{First Iteration}
\label{ch:firstiteration}
The solution to the stated problem was approached in an iterative manner. This section describes the first iteration, which focuses on laying the groundwork for future work. Because of this, the model produced is rather abstract.

The iteration was split into four major steps, described below.

\begin{enumerate}
\item Design and implement a UPPAAL CORA model, simulating the FESTO system
\item Make UPPAAL CORA and Python 3.5 cooperate \funote{Maybe the meaning of this should be more explicit}
\item Use Python to generate valid model configurations, that produce specific products
\item Pick out the best configuration from a pool of candidates
\end{enumerate}

In the following we go over each of these steps in further detail.

\section{Design and Implementation in UPPAAL CORA}
For our models we use UPPAAL, an integrated tool environment used for modelling, simulating and verifying real time systems. When a model has been constructed, the model checker may be used to query invariant and reachability properties of the model. We choose UPPAAL, as we have previous experience with it, as well as the theory of timed automatas. In addition, many of its developers are located in Aalborg University along with the project group. Thus there is easy access to technical advice.

After a FESTO factory has been modelled, we may query it about its properties. The most interesting property is one of reachability; is it possible to reach a state, where x amount of products have been produced? If this is the case, UPPAAL may produce a shortest timed trace of actions needed to reach this state. However, the fastest trace is not always the best, for instance, a very fast trace may have the factory use up a lot of power. Thus, high throughput is not the only desired property for the factory, but a low cost is wanted as well. In order to involve costs, a branch of UPPAAL, called UPPAAL CORA is used.

This program is very similar to regular UPPAAL, but it also allows for a global cost variable to be used, alongside the global clock. This variable is strictly non-decreasing. The cost can be increased either when an action is taken, or as a function of time, when waiting in a location. The model checker may explore the state space in a UPPAAL CORA model in a best-first manner. That is, it looks for a trace to the goal state with the smallest global cost value.

As mentioned in \cref{ch:introduction}, this project differs from others before it, as we are working with a system of not only one, but many different configurations. Thus, when modelling in UPPAAL CORA, a strong focus was put on not hard coding the model. Instead we design and implement templates, which can later be instantiated with different parameters. The instantiated templates can then be run in parallel, as a single functioning factory configuration.

In \cref{subs:recipe,subs:module,subs:remover,subs:coster}, the developed templates, that make up the current model, are explained.

\subsection{Recipe}
\label{subs:recipe}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{images/firstrecipe.png}
\caption{The model of the recipe template}
\label{fig:firstrecipe}
\end{figure}

To represent an item passing through a FESTO factory, the \emph{recipe template} is designed and implemented. This defines a set of steps that must be taken to create a specific product. A recipe synchronises with a module to have work performed on it. Each module has a specific type of work, which it may perform on a recipe. The \emph{recipe template} can be seen in \cref{fig:firstrecipe}.


A recipe is initialised with an ID, along with an array of arrays. The latter construct describes the dependency between steps, that must be taken for a recipe to move to its end location. Each array layer describes a set of steps that may be taken in an arbitrary manner. However all these steps must be taken, before any of the steps in the next layer may be taken. For instance, the dependency structure [[Hammer, Screw][Package]], means that the given recipe should get hammered and screwed before it is packaged. However the hammering and screwing may occur in an arbitrary sequence.


When transitioning from the \emph{start} location, a recipe will, through the \emph{transport} channel, synchronise with the first module in the production line. Through the global \emph{var} variable, the ID of the recipe is passed to the module in order for it to lay claim on it. This is part of a simple mutual exclusion scheme, making sure that a module can only work on one specific recipe at a time. Once a recipe is in progress, it may handshake with a module by using its ID to identify itself. When identified, the module may perform a work action upon the recipe to complete a pending recipe step. If a work action has been done, we make sure to mark the finished step as done, so that it is not repeated. In the case that all steps have been taken, in a layer of the dependency array, we make sure to move onto the next. Once all layers have been completed, we may pass to the end location. Here, we set the local \emph{done} variable to true. This is used to query our model checker to see if we can reach a state where the recipe is finished. For a recipe, \emph{r1}, the query would be \[E<> r1.done\].

\subsection{Module}
\label{subs:module}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{images/firstmodule.png}
\caption{The model of the module template}
\label{fig:firstmodule}
\end{figure}

The \emph{module template} models a module in a FESTO factory. A module is identified by its ID parameter. A second parameter \emph{wid} (work id) indicates the type of work the module may perform on a recipe. A module also includes an array, \emph{next}, which contains IDs of modules, which it may pass an item onto. The \emph{module template} can be seen in \cref{fig:firstmodule}.


To transition from the \emph{idle location}, a module must receive an item from a module earlier in line by synchronising on the \emph{transport} channel.
As stated in \cref{subs:module}, the first \emph{transport} occurs between a recipe and the first module in line. This also passes the recipe ID onto the module, in order to lock other recipes out, saving the recipe ID in the \emph{lock} variable. From this point on, when a module synchronises on \emph{transport}, it passes the recipe ID onto the next module for locking.

After transitioning to the \emph{transporting} location, the module waits for \emph{t\_time}. Afterwards it may synchronise on \emph{transport} again, to send the recipe to one of the next modules in line. Instead of passing on the recipe, we may try to work upon it.

By giving the option of working or passing through, we simulate that some items do not need to be worked on, by every module in the production line. If we decide to work on the recipe, we go to the \emph{processing} location and wait for \emph{p\_time}. Each time we delay by a single time unit in this location, the global \emph{cost} variable is increased by the value of \emph{cost\_rate}. Once \emph{p\_time} has passed, the module can identify its recipe through a handshake by using the recipe ID saved in \emph{lock}. Once it is confirmed, that the module is working with the correct recipe, it will synchronise on the \emph{work channel}, finishing its job upon the item. Once finished, the module may go back to the \emph{idle} location by transporting the item to one of the next modules in line.

\subsection{Remover}
\label{subs:remover}

\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{images/firstremover.png}
\caption{The model of the remover template}
\label{fig:firstremover}
\end{figure}

The \emph{remover template} is not very complex, and can be seen in \cref{fig:firstremover}. It continously tries to synchronise on the \emph{transport} channel 0, in order to remove a recipe from the factory. The factory modules each have their own \emph{transport} channel, given by their ID, which is 1-indexed. Thus, a \emph{transport} on channel 0 does not pass the recipe to a module, but instead to the remover. If we want to remove a recipe, when it is passed on from a specific module, we simply set one of the IDs in the module’s next array to 0. Removing a recipe from a factory is especially beneficial in circular setups, as a finished recipe may otherwise be passed around indefinitely. This may unnecessarily decrease factory throughput. By removing recipes. We also decrease the state space that needs to be searched by the model checker.

\subsection{Coster}
\label{subs:coster}

\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{images/firstcoster.png}
\caption{The model of the coster template}
\label{fig:firstcoster}
\end{figure}

The \emph{coster template} ensures that parallel processing of recipes is prefered, during a best-first Search. It can be seen in \cref{fig:firstcoster} The \emph{coster template} is initialised with a rate \emph{c}, which increases the \emph{cost} variable as a function of the global time passed. Without this, the search would not have any reason to run several modules at the same time as the final \emph{cost} would not change. By having a constant \emph{cost} on the factory’s operating time, we make the prospect of parallel processing a prefered option.
